\externaldocument{theory.tex}



\chapter{Implementace}
Součástí bakalářské práce byl vytvořen řešič numerických CSP s~názvem \emph{HullSolver}, který jako jediný volně dostupný řešič umožňuje porovnávat efektivitu použitých heuristik. Zdrojové kódy jsou dostupné pod licencí GNU GPL na~serveru GitHub\footnote{\url{https://github.com/jakubkottnauer/hull-solver}}, případně jsou k nalezení i na~přiloženém CD. Manuál popisující kompilaci, spuštění a použití programu je uveden na~konci práce v~příloze \ref{hullSolverManual}.

Tato část práce nejprve popisuje použité technologie a algoritmy v~programu HullSolver, následně se věnuje popisuje architektury programu a na~závěr uvádí několik existujících řešení, které řeší podobné problémy.


\section{Použité technologie}
Jako jazyk pro implementaci byl zvolen funkcionální jazyk \texttt{F\#} (čteno jako F Sharp) běžící na~platformě .NET, který se v~posledních letech stal velmi populární pro vědecké využití. Tento jazyk byl poprvé uveden v~roce 2005 společností Microsoft, v~roce 2013 byla ale založena nezisková společnost \texttt{F\#} Software Foundation, která má na~starosti jeho další vývoj. Od té doby se z~jazyka stal open-source a díky projektu Mono je možné aplikaci napsané v~\texttt{F\#} spouštět i na~jiných platformách, než pouze na~Microsoft Windows.

\section{Algoritmy}

S~vedoucím práce bylo dohodnuto, že řešič bude podporovat omezující podmínky s~operacemi sčítání, odčítání a násobení.

Řešení vstupních problémů probíhá s~využitím algoritmu HC3 s~malou úpravou pro pestřejší možnosti využití heuristik. Zatímco originální algoritmus vždy vybere z~množiny podmínek jednu náhodnou a zredukuje domény všech proměnných v~ní obsažených, upravený algoritmus na vstupu přijímá množinu všech dvojic $(c, x)$ (kde $c$ je omezující podmínka definovaná nad proměnnou $x$) a z této množiny heuristicky vybírá jednu dvojici. Následně podle podmínky $c$ zúží doménu proměnné $x$. Omezující podmínka $c$ se tedy na vstupu objeví tolikrát, nad kolika proměnnými je nadefinována - v případě programu HullSolver vždy právě třikrát, neboť program podporuje pouze ternární omezující podmínky. Algoritmus~\ref{HC3AlgorithmAltered} uvádí pseudokód takto upraveného algoritmu HC3.

\begin{algorithm}
\caption{Upravený algoritmus HC3}
\label{HC3AlgorithmAltered}
\begin{algorithmic}[1]
\Require Seznam $P$ dvojic $(c, x)$, kde $c$ je omezující podmínka definovaná nad proměnnou $x$, a množina domén $D$ z CSP.
\Ensure Informace o nekonzistenci, nebo zmenšený problém $P$.
\Procedure{HC3}{$P, D$}
\State $Q \gets P$
\While{$Q \neq \emptyset$ }
\State Pomocí heuristiky vyber z $Q$ pár $p = (c, x)$.
\State $Q \gets Q \setminus \left\{ p \right\}$
\State $D_x' \gets$ Zredukuj doménu $D_x \in D$ proměnné $x \in p$ podle $c$.
\If{$D_x' = \emptyset $}
\State \Return CSP je nekonzistentní.
\EndIf
\If{$D_x \neq D_x'$}
\State $D_x \gets D_x'$
\State Přidej do $Q$ pár $p$ a všechny další páry z $P$, které obsahují $x$.
\EndIf
\EndWhile
\State \Return $P$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Na řádku č.~7 v algoritmu \ref{HC3AlgorithmAltered} jsou pro rovnost porovnávány dvě domény. Vzhledem k tomu, že jsou zde domény tvořeny reálnými intervaly, nemusí být jejich meze celá čísla a v počítači tak nebudou uložena přesně (v programu je pro reprezentaci mezí využit 64-bitový typ \verb|double|). Rovnost je v programu ověřována nepřesně, jak ukazuje následující kód (jako \verb|ZERO_EPSILON| je použita hodnota $10^{-30}$):

\begin{Verbatim}[samepage=true]
member this.EqualTo y =
  abs(this.a - y.a) < ZERO_EPSILON 
  && abs(this.b - y.b) < ZERO_EPSILON
\end{Verbatim}

Nad algoritmem HC3 je postaven jednoduchý branch-and-prune algoritmus (viz Algoritmus \ref{BranchPrune}), který zároveň tvoří hlavní funkci řešiče. Tento algoritmus přibližně kopíruje strukturu algoritmu~\ref{alg:GeneralSolutionAlg} (str.~\pageref{alg:GeneralSolutionAlg}), jen je zde využit rekurzivní zápis. Při spuštění je mu předána množina dvojic omezujících podmínek a proměnných v~nich obsažených.

\begin{algorithm}
\caption{Rekurzivní algoritmus Solve}
\label{BranchPrune}
\begin{algorithmic}[1]
\Require Seznam $P$ dvojic $(c, x)$, kde $c$ je omezující podmínka definovaná nad proměnnou $x$, a množina domén $D$ z CSP.
\Ensure Seznam nalezených boxů.
\Procedure{Solve}{$P, D$}
\If{Problém není dostatečně malý}
\State $P' \gets HC3(P)$
\State $(P_1, P_2) \gets $ rozděl box tvořený doménami dominantních proměnných z $D$ na poloviny.
\State Solve($P_1$)
\State Solve($P_2$)
\Else
\State Vypiš/ulož box tvořený proměnnými z $P$ jako jeden z výsledků.
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

V použité variantě algoritmu \verb|Solve| je kontrolováno, zda je problém již dostatečně zmenšen. V programu se konkrétně kontroluje, jestli se již podařilo domény všech dominantních proměnných dostatečně zúžit vzhledem k původní velikosti. Jako koeficient pro porovnání se využívá parametr \verb|eps|, který je specifikován uživatelem při spuštění řešiče přepínačem \verb|-p| (viz manuál).

\begin{Verbatim}[samepage=true]
member this.AllFraction eps =
  dominantVariables 
  |> List.forall(fun v -> 
    (v.Domain.Length / v.OriginalDomain.Length) < eps)
\end{Verbatim}


Druhým prvkem algoritmu \verb|Solve|, jehož implementace je potřeba upřesnit, je rozpůlení boxu na řádku č.~4. Box, jak je popsáno v kapitole \ref{ch:ncsp} je ohraničením okolo řešení tvořeným doménami proměnných z CSP. Algoritmus box rozpůlí tím, že rozpůlí doménu jedné dominantní proměnné. Ve vstupním souboru uživatel označí dominantní proměnné a algoritmus je půlí metodou round-robin ve stejném pořadí, jako jsou zapsány ve vstupním souboru (při rozpůlení poslední dominantní proměnné přeskočí opět na první).


\section{Architektura}
Celý program se skládá ze čtyř souborů - \verb|DomainTypes.fs|, \verb|Heuristics.fs|, \verb|Solver.fs|, \verb|Program.fs|. Při kompilování programu napsaného v~\texttt{F\#} záleží na~pořadí souborů a v~tomto případě jsou soubory zpracovávany v~tomto pořadí. Braním ohledu na~pořadí souborů kompilátor zabraňuje tvorbě kruhových závislostí mezi částmi programu, protože soubor později ve frontě může využívat pouze typy z~již zpracovaného souboru. Kód se tak stává modulárnější a přehlednější, protože přirozeně dochází ke striktnímu oddělení \uv{high-level} částí programů od \uv{low-level} částí.

Dalším důsledkem je odlišná organizace kódu v~podobných jazycích jako \texttt{F\#} od klasických procedurálních či objektově orientovaných jazyků. V~\texttt{F\#} se typicky nevytváří samostatný soubor pro každý typ (typ přibližně odpovídá třídě z~objektově orientovaného programování), ale všechny typy se shlukují do jednoho modulu často nazývaného \verb|DomainTypes|. V~případě HullSolveru jsou doménovými typy \verb|Interval|, \verb|Variable|, \verb|Constraint|, \verb|Problem| a \verb|Heuristic|, z~nichž poslední se pro přehlednost nachází v~samostatném souboru \verb|Heuristics.fs|.

Zatímco první dva soubory obsahují především deklarace typů a definují jejich funkce, soubor \verb|Solver.fs| tvoří hlavní výpočetní jádro programu - zde jsou implementace branch-and-prune algoritmu a algoritmu HC3. Posledním souborem je \verb|Program.fs|, který se už stará jen o ošetření a zpracování vstupu a spouští řešící algoritmy.

\section{Výstup programu a indikátory}
\label{ch:indicators}
V průběhu řešení problémů je sledováno několik tzv. indikátorů. To jsou různé zajímavé metriky, pomocí kterých se dá následně porovnat efektivita heuristik. Kromě času běhu algoritmu (který je ale spíše pouze ilustrativní, protože se může měnit mezi jednotlivými spuštěními) jsou sledovány indikátory:

\begin{itemize}
    \item počet rozpůlení řešení,
    \item počet zúžení intervalů,
    \item poměr objemu řešení k objemu vstupního CSP.
\end{itemize}





\section{Vylepšení programu}
Program v~této době neumí sám dekomponovat omezující podmínky v~komplexním tvaru a je proto nutné je zadávat v~primitivním tvaru. HullSolver rovněž neprovádí detekci redundantních podmínek.

Dalším vylepšením by mohlo být přidání grafického rozhraní (vykreslování grafů s řešením).






\section{Existující řešení}
Vzhledem k obecnosti termínu CSP existuje velké množství aplikací řešících problémy s~omezujícími podmínkami - lze nalézt nespočet řešičů sudoku i řešičů SAT problému. Vzniklo také několik obecných řešičů, například \emph{Geocode}\footnote{http://www.gecode.org} a \emph{Microsoft Solver Foundation}\footnote{https://msdn.microsoft.com/en-us/library/ff524509(v=vs.93).aspx}.

Řešení NCSP problémů pomocí propagace intervalů je již poměrně specifická oblast a tak těchto řešičů není mnoho. Na~službě GitHub patří mezi nejznámější řešiče projekt \emph{JaCoP}\footnote{\url{https://github.com/radsz/jacop}}, dále existují například \emph{IASolver}\footnote{\url{http://www.cs.brandeis.edu/~tim/Applets/IAsolver.html}}, \emph{RSolver}\footnote{\url{http://rsolver.sourceforge.net}} a \emph{RealPaver}\footnote{\url{https://github.com/lcgutierrez/Realpaver-0\_4-Windows}}. První dva projekty jsou napsány v~Javě, třetí v~jazyce OCaml a čtvrtý v~C. Žádný z~nich ale není dále vyvíjen.
